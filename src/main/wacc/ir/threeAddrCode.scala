package wacc.ir

import wacc.ast._

object threeAddrCode {
  sealed trait TLabel

  // string labels defined at the top of the file
  case class TStringLabel(val id: Int, val value: String) extends TLabel {
    override def toString: String = s":l${value.size}:.L.str$id - $value"
  }

  sealed trait TJumpLabel extends TLabel with ThreeAddrInstr
  // functions made by the user
  case class TFuncLabel(val name: String) extends TJumpLabel {
    override def toString(): String = s"FuncLabel: $name"
  }
  // branch labels generated by this compiler
  case class TBranchLabel(val id: Int) extends TJumpLabel {
    override def toString(): String = s"BranchLabel: $id"
  }

  // TLoc stores an arbitrary location in three address code 
  // (This gets mapped to the correct register in codegen)
  sealed trait TLoc
  case class TRegLoc(val id: Int) extends TLoc {
    override def toString: String = s"l$id"
  }

  case class TArgLoc(val id: Int) extends TLoc {
    override def toString(): String = s"arg$id"
  }

  case object TTempLoc1 extends TLoc {
    override def toString: String = s"t0"
  }

  case object TTempLoc2 extends TLoc {
    override def toString: String = s"t1"
  }

  class TImm(val value: Int) {
    override def toString: String = s"#$value"
  }

  // Set of Three Address Instructions for this IR, designed to be flexible for different architectures
  sealed trait ThreeAddrInstr

  // Unary operators
  sealed trait TUnOp extends ThreeAddrInstr
  case class TNOT(dest: TLoc, src: TLoc) extends TUnOp
  case class TNEG(dest: TLoc, src: TLoc) extends TUnOp
  case class TLEN(dest: TLoc, src: TLoc) extends TUnOp
  case class TORD(dest: TLoc, src: TLoc) extends TUnOp
  case class TCHR(dest: TLoc, src: TLoc) extends TUnOp


  // Binary operators
  sealed trait TBinOp extends ThreeAddrInstr
  case class TMUL(dest: TLoc, lsrc: TLoc, rsrc: TLoc) extends TBinOp {
    override def toString: String = s"MUL($dest, $lsrc, $rsrc)"
  }

  case class TDIV(dest: TLoc, lsrc: TLoc, rsrc: TLoc) extends TBinOp {
    override def toString: String = s"DIV($dest, $lsrc, $rsrc)"
  }

  case class TMOD(dest: TLoc, lsrc: TLoc, rsrc: TLoc) extends TBinOp {
    override def toString: String = s"MOD($dest, $lsrc, $rsrc)"
  }

  case class TADD(dest: TLoc, lsrc: TLoc, rsrc: TLoc) extends TBinOp {
    override def toString: String = s"ADD($dest, $lsrc, $rsrc)"
  }

  case class TSUB(dest: TLoc, lsrc: TLoc, rsrc: TLoc) extends TBinOp {
    override def toString: String = s"SUB($dest, $lsrc, $rsrc)"
  }

  case class TGT(dest: TLoc, lsrc: TLoc, rsrc: TLoc) extends TBinOp {
    override def toString: String = s"GT($dest, $lsrc, $rsrc)"
  }

  case class TGTE(dest: TLoc, lsrc: TLoc, rsrc: TLoc) extends TBinOp {
    override def toString: String = s"GTE($dest, $lsrc, $rsrc)"
  }

  case class TLT(dest: TLoc, lsrc: TLoc, rsrc: TLoc) extends TBinOp {
    override def toString: String = s"LT($dest, $lsrc, $rsrc)"
  }

  case class TLTE(dest: TLoc, lsrc: TLoc, rsrc: TLoc) extends TBinOp {
    override def toString: String = s"LTE($dest, $lsrc, $rsrc)"
  }

  case class TEQ(dest: TLoc, lsrc: TLoc, rsrc: TLoc) extends TBinOp {
    override def toString: String = s"EQ($dest, $lsrc, $rsrc)"
  }

  case class TNEQ(dest: TLoc, lsrc: TLoc, rsrc: TLoc) extends TBinOp {
    override def toString: String = s"NEQ($dest, $lsrc, $rsrc)"
  }

  // Storing Instructions
  /* store (value at srcTLoc) to memory location in (memoryDest + offset * minimum memory size) */
  case class TStore(srcTLoc: TLoc, memoryDest: TLoc, offset: TLoc) extends TBinOp {
    override def toString: String = s"Store($srcTLoc, [$memoryDest, $offset])"
  }

  case class TCharStore(srcTLoc: TLoc, memoryDest: TLoc, offset: TLoc) extends TBinOp {
    override def toString: String = s"ChrStore($srcTLoc, [$memoryDest, $offset])"
  }

  case class TPtrStore(srcTLoc: TLoc, memoryDest: TLoc, offset: TLoc) extends TBinOp {
    override def toString: String = s"PtrStore($srcTLoc, [$memoryDest, $offset])"
  }

  /* Store only 1 byte and check the bound */
  case class TCharArrElemStore(srcTLoc: TLoc, memoryDest: TLoc, offset: TLoc) extends TBinOp {
    override def toString: String = s"ChrStore($srcTLoc, [$memoryDest, $offset])"
  }

  case class TPtrArrElemStore(srcTLoc: TLoc, memoryDest: TLoc, offset: TLoc) extends TBinOp {
    override def toString: String = s"PtrArrElemStore($srcTLoc, [$memoryDest, $offset])"
  }

  /* Store a normal sized data in array and check array out of bound */
  case class TArrElemStore(srcTLoc: TLoc, memoryDest: TLoc, offset: TLoc)  extends TBinOp {
    override def toString: String = s"ArrElemStore($srcTLoc, [$memoryDest, $offset])"
  }

  /* Store in a pair, Null check pair */
  case class TPairElemStore(srcTLoc: TLoc, memoryDest: TLoc, offset: TLoc)  extends TBinOp {
    override def toString: String = s"PairArrElemStore($srcTLoc, [$memoryDest, $offset])"
  }


  // Loading Instructions
  /* load value from memory (memorySrc + offset) to (location(register) at destTLoc)*/
  case class TLoad(destTLoc: TLoc, memorySrc: TLoc, offset: TLoc)  extends TBinOp {
    override def toString: String = s"Load($destTLoc, [$memorySrc, $offset])"
  }

  /* load value from memory (memorySrc + offset) to (location(register) at destTLoc)*/
  case class TCharArrElemLoad(destTLoc: TLoc, memorySrc: TLoc, offset: TLoc)  extends TBinOp {
    override def toString: String = s"CharArrLoad($destTLoc, [$memorySrc, $offset])"
  }

  case class TPtrArrElemLoad(destTLoc: TLoc, memorySrc: TLoc, offset: TLoc)  extends TBinOp {
    override def toString: String = s"PtrArrLoad($destTLoc, [$memorySrc, $offset])"
  }

  /* Store in an array, check array out of bound */
  case class TArrElemLoad(destTLoc: TLoc, memorySrc: TLoc, offset: TLoc)  extends TBinOp {
    override def toString: String = s"ArrLoadS($destTLoc, [$memorySrc, $offset])"
  }

  /* Store in a pair, Null check pair */
  case class TPairElemLoad(destTLoc: TLoc, memorySrc: TLoc, offset: TLoc)  extends TBinOp {
    override def toString: String = s"ArrLoad($destTLoc, [$memorySrc, $offset])"
  }

  case class TStrLoad(loc: TLoc, str: TStringLabel) extends TBinOp {
    override def toString: String = s"StrLoad($loc, $str)"
  }

  // Represents a no-operation instruction
  case class TSkip()                               extends ThreeAddrInstr
  // Represents an assignment of an immediate value to a location
  case class TAssignImm(dest: TLoc, tImm: TImm)    extends ThreeAddrInstr {
    override def toString: String = s"Assign($dest, $tImm)"
  }
  // Represents an assignment of a value from one location to another
  case class TAssignLoc(dest: TLoc, src: TLoc)  extends ThreeAddrInstr {
    override def toString: String = s"Assign($dest, $src)"
  }

  // Represents an unconditional jump to a label
  case class TJump(label: TBranchLabel)                    extends ThreeAddrInstr
  // Represents a conditional jump to a label based on the value at a location
  case class TJumpCond(condSrc: TLoc, label: TBranchLabel) extends ThreeAddrInstr

  // Represents a function call with arguments and a destination for the result
  case class TCall(func: String, args: List[TLoc], dest: TLoc) extends ThreeAddrInstr
  // Represents a return instruction with a location holding the return value
  case class TReturn(loc: TLoc) extends ThreeAddrInstr
  // Represents an exit instruction with a location holding the exit value
  case class TExit(loc: TLoc)   extends ThreeAddrInstr

  // Represents a print instruction for an integer, string, character, boolean value at a location, with an optional new line
  case class TPrintI(loc: TLoc, newLine: Boolean) extends ThreeAddrInstr
  case class TPrintS(loc: TLoc, newLine: Boolean) extends ThreeAddrInstr
  case class TPrintC(loc: TLoc, newLine: Boolean) extends ThreeAddrInstr
  case class TPrintB(loc: TLoc, newLine: Boolean) extends ThreeAddrInstr

  case class TPrintP(loc: TLoc, newLine: Boolean) extends ThreeAddrInstr // pair and array pointer
  case class TReadI(loc: TLoc)  extends ThreeAddrInstr // Should put to ArgTLoc(0) and get return from RetTLoc(0)
  case class TReadC(loc: TLoc)  extends ThreeAddrInstr // Should put to ArgTLoc(0) and get return from RetTLoc(0)
  case class TFreeA(src: TLoc)  extends ThreeAddrInstr // Should put to ArgTLoc(0) and get return from RetTLoc(0)
  case class TFreeP(src: TLoc)  extends ThreeAddrInstr // Should put to ArgTLoc(0) and get return from RetTLoc(0)

  case class TMallocArray(dest: TLoc, size: Int) extends ThreeAddrInstr // Should put malloc size to ArgTLoc(0) and get pointer from RetTLoc(0)
  case class TMallocCharArray(dest: TLoc, size: Int) extends ThreeAddrInstr
  case class TMallocPtrArray(dest: TLoc, size: Int) extends ThreeAddrInstr
  case class TMallocPair(dest: TLoc) extends ThreeAddrInstr // Should put malloc size to ArgTLoc(0) and get pointer from RetTLoc(0)
}
